import { 
  IAIProvider, 
  ProviderRegistry, 
  AIProviderConfig, 
  ProviderType,
  AIProviderError,
  ConversationContext,
  AIResponse
} from './base/IAIProvider';

// Provider Factory and Registry Implementation
export class AIProviderFactory implements ProviderRegistry {
  private providers: Map<string, IAIProvider> = new Map();
  private configs: Map<string, AIProviderConfig> = new Map();
  
  // Provider registration
  register(provider: IAIProvider): void {
    this.providers.set(provider.name, provider);
    this.configs.set(provider.name, provider.config);
    console.log(`‚úÖ AI Provider registered: ${provider.config.displayName}`);
  }
  
  unregister(providerName: string): void {
    this.providers.delete(providerName);
    this.configs.delete(providerName);
    console.log(`‚ùå AI Provider unregistered: ${providerName}`);
  }
  
  getProvider(providerName: string): IAIProvider | undefined {
    return this.providers.get(providerName);
  }
  
  getAllProviders(): IAIProvider[] {
    return Array.from(this.providers.values());
  }
  
  getEnabledProviders(): IAIProvider[] {
    return Array.from(this.providers.values())
      .filter(provider => provider.config.isEnabled);
  }
  
  getPrimaryProvider(): IAIProvider | undefined {
    const enabledProviders = this.getEnabledProviders();
    return enabledProviders.length > 0 
      ? enabledProviders.sort((a, b) => a.config.priority - b.config.priority)[0]
      : undefined;
  }
  
  getFallbackProviders(): IAIProvider[] {
    return this.getEnabledProviders()
      .sort((a, b) => a.config.priority - b.config.priority)
      .slice(1); // Skip primary provider
  }
  
  // Factory methods
  async createProvider(type: ProviderType, config: AIProviderConfig): Promise<IAIProvider> {
    let provider: IAIProvider;
    
    switch (type) {
      case ProviderType.OPENAI:
        const { OpenAIProvider } = await import('./providers/OpenAIProvider');
        provider = new OpenAIProvider();
        break;
        
      case ProviderType.CLAUDE:
        const { ClaudeProvider } = await import('./providers/ClaudeProvider');
        provider = new ClaudeProvider();
        break;
        
      case ProviderType.GEMINI:
        const { GeminiProvider } = await import('./providers/GeminiProvider');
        provider = new GeminiProvider();
        break;
        
      case ProviderType.LOCAL_LLM:
        const { LocalLLMProvider } = await import('./providers/LocalLLMProvider');
        provider = new LocalLLMProvider();
        break;
        
      case 'mock' as ProviderType:
        const { MockProvider } = await import('./providers/MockProvider');
        provider = new MockProvider();
        break;
        
      default:
        throw new AIProviderError(`Unknown provider type: ${type}`, 'factory');
    }
    
    await provider.initialize(config);
    return provider;
  }
  
  // Intelligent routing and fallback
  async generateResponse(
    context: ConversationContext,
    preferredProvider?: string
  ): Promise<AIResponse> {
    console.log('üè≠ AIProviderFactory.generateResponse called:', {
      userId: context.userId,
      messageCount: context.messages?.length || 0,
      preferredProvider
    });
    
    const providers = this.getProvidersForTask(context, preferredProvider);
    console.log('üè≠ Selected providers for task:', providers.map(p => ({ name: p.name, enabled: p.config.isEnabled })));
    
    if (providers.length === 0) {
      console.error('‚ùå No providers available for task');
      throw new AIProviderError('No providers available', 'factory');
    }
    
    for (const provider of providers) {
      try {
        console.log(`ü§ñ Trying provider: ${provider.name}`);
        
        // Check provider health before using
        const isHealthy = await provider.isHealthy();
        console.log(`ü§ñ Provider ${provider.name} health check:`, isHealthy);
        
        if (!isHealthy) {
          console.warn(`‚ö†Ô∏è Provider ${provider.name} is unhealthy, skipping...`);
          continue;
        }
        
        const startTime = Date.now();
        console.log(`ü§ñ Calling generateResponse on ${provider.name}...`);
        
        const response = await provider.generateResponse(context);
        
        // Add latency to response metadata
        response.metadata.latency = Date.now() - startTime;
        
        console.log(`‚úÖ Response generated by ${provider.name} in ${response.metadata.latency}ms`);
        return response;
        
      } catch (error) {
        console.error(`‚ùå Provider ${provider.name} failed:`, error);
        
        // If it's the last provider, throw the error
        if (provider === providers[providers.length - 1]) {
          console.error('‚ùå All providers failed, throwing error');
          throw error;
        }
        
        // Otherwise, continue to next provider
        console.log(`üîÑ Continuing to next provider...`);
        continue;
      }
    }
    
    throw new AIProviderError('All providers failed', 'factory');
  }
  
  // Smart provider selection based on task type and context
  private getProvidersForTask(
    context: ConversationContext, 
    preferredProvider?: string
  ): IAIProvider[] {
    const enabledProviders = this.getEnabledProviders();
    
    console.log('üè≠ getProvidersForTask called:', {
      enabledProvidersCount: enabledProviders.length,
      preferredProvider,
      allProviders: this.getAllProviders().map(p => ({ name: p.name, enabled: p.config.isEnabled }))
    });
    
    if (enabledProviders.length === 0) {
      console.error('‚ùå No enabled providers available');
      throw new AIProviderError('No enabled providers available', 'factory');
    }
    
    // If preferred provider is specified and available, use it first
    if (preferredProvider) {
      const preferred = this.getProvider(preferredProvider);
      console.log(`üè≠ Preferred provider ${preferredProvider}:`, {
        found: !!preferred,
        enabled: preferred?.config.isEnabled
      });
      
      if (preferred && preferred.config.isEnabled) {
        const others = enabledProviders.filter(p => p.name !== preferredProvider);
        const result = [preferred, ...others.sort((a, b) => a.config.priority - b.config.priority)];
        console.log('üè≠ Using preferred provider first:', result.map(p => p.name));
        return result;
      }
    }
    
    // Route based on task characteristics
    const sortedProviders = [...enabledProviders].sort((a, b) => {
      // Prefer providers based on message length and complexity
      const messageLength = context.messages.reduce((acc, msg) => acc + msg.content.length, 0);
      
      // For long conversations, prefer providers with larger context windows
      if (messageLength > 50000) {
        const aContextWindow = a.config.models[0]?.contextWindow || 0;
        const bContextWindow = b.config.models[0]?.contextWindow || 0;
        if (aContextWindow !== bContextWindow) {
          return bContextWindow - aContextWindow;
        }
      }
      
      // Default to priority ordering
      return a.config.priority - b.config.priority;
    });
    
    console.log('üè≠ Final provider order:', sortedProviders.map(p => ({ name: p.name, priority: p.config.priority })));
    return sortedProviders;
  }
  
  // Cost optimization
  async estimateCosts(context: ConversationContext): Promise<Map<string, number>> {
    const costs = new Map<string, number>();
    const enabledProviders = this.getEnabledProviders();
    
    for (const provider of enabledProviders) {
      try {
        const cost = await provider.estimateCost(context);
        costs.set(provider.name, cost);
      } catch (error) {
        console.warn(`Failed to estimate cost for ${provider.name}:`, error);
        costs.set(provider.name, 0);
      }
    }
    
    return costs;
  }
  
  // Health check for all providers
  async checkProvidersHealth(): Promise<Map<string, boolean>> {
    const healthStatus = new Map<string, boolean>();
    const allProviders = this.getAllProviders();
    
    const healthChecks = allProviders.map(async (provider) => {
      try {
        const isHealthy = await provider.isHealthy();
        healthStatus.set(provider.name, isHealthy);
      } catch (error) {
        console.error(`Health check failed for ${provider.name}:`, error);
        healthStatus.set(provider.name, false);
      }
    });
    
    await Promise.all(healthChecks);
    return healthStatus;
  }
  
  // Get provider statistics
  async getProviderStats(): Promise<Map<string, any>> {
    const stats = new Map<string, any>();
    
    for (const provider of this.getAllProviders()) {
      if (provider.getUsageStats) {
        try {
          const providerStats = await provider.getUsageStats();
          stats.set(provider.name, providerStats);
        } catch (error) {
          console.warn(`Failed to get stats for ${provider.name}:`, error);
        }
      }
    }
    
    return stats;
  }
}

// Singleton instance
export const aiProviderFactory = new AIProviderFactory();

// Utility functions for provider management
export class ProviderManager {
  private factory: AIProviderFactory;
  
  constructor(factory: AIProviderFactory) {
    this.factory = factory;
  }
  
  // Initialize all providers from configuration
  async initializeProviders(configs: AIProviderConfig[]): Promise<void> {
    const initPromises = configs.map(async (config) => {
      try {
        const providerType = config.name as ProviderType;
        const provider = await this.factory.createProvider(providerType, config);
        this.factory.register(provider);
      } catch (error) {
        console.error(`Failed to initialize provider ${config.name}:`, error);
      }
    });
    
    await Promise.all(initPromises);
    
    const enabledCount = this.factory.getEnabledProviders().length;
    console.log(`üöÄ Initialized ${enabledCount} AI providers`);
  }
  
  // Hot-reload provider configuration
  async reloadProvider(providerName: string, newConfig: AIProviderConfig): Promise<void> {
    try {
      // Unregister existing provider
      this.factory.unregister(providerName);
      
      // Create and register new provider with updated config
      const providerType = providerName as ProviderType;
      const provider = await this.factory.createProvider(providerType, newConfig);
      this.factory.register(provider);
      
      console.log(`üîÑ Provider ${providerName} reloaded successfully`);
    } catch (error) {
      console.error(`Failed to reload provider ${providerName}:`, error);
      throw error;
    }
  }
  
  // Get provider configuration for UI
  getProviderConfigs(): AIProviderConfig[] {
    return this.factory.getAllProviders().map(provider => provider.config);
  }
  
  // Update provider priority
  async updateProviderPriority(providerName: string, newPriority: number): Promise<void> {
    const provider = this.factory.getProvider(providerName);
    if (provider) {
      provider.config.priority = newPriority;
      console.log(`üìù Updated priority for ${providerName} to ${newPriority}`);
    }
  }
}

export const providerManager = new ProviderManager(aiProviderFactory);